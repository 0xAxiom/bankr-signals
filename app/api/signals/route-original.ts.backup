import { NextRequest, NextResponse } from "next/server";
import { dbGetSignals, dbGetSignalsByProvider, dbGetProvider, dbAddSignal, supabase } from "@/lib/db";
import { verifySignature } from "@/lib/auth";
import { 
  checkRateLimit, 
  rateLimitResponse, 
  getClientIP, 
  RATE_LIMITS, 
  detectAbuse 
} from "@/lib/ratelimit";
import {
  createSuccessResponse,
  createErrorResponse,
  validateRequest,
  ValidationPatterns,
  CustomValidators,
  APIErrorCode,
  dbToApiSignal,
  validateRequestSize,
} from "@/lib/api-utils";
import { SignalAction, SignalCategory, RiskLevel, TimeFrame, SignalStatus } from "@/lib/types";

export const dynamic = "force-dynamic";

const VALID_ACTIONS = Object.values(SignalAction);
const VALID_CATEGORIES = Object.values(SignalCategory);
const VALID_RISK_LEVELS = Object.values(RiskLevel);
const VALID_TIME_FRAMES = Object.values(TimeFrame);

// Fire webhook notifications (async, don't block response)
async function fireWebhooks(signal: any) {
  try {
    // Query active webhooks matching the signal
    const { data: webhooks } = await supabase
      .from("webhooks")
      .select("*")
      .eq("active", true);

    if (!webhooks || webhooks.length === 0) return;

    const matchingWebhooks = webhooks.filter(webhook => {
      // Check provider filter
      if (webhook.provider_filter && 
          webhook.provider_filter.toLowerCase() !== signal.provider.toLowerCase()) {
        return false;
      }
      
      // Check token filter
      if (webhook.token_filter && 
          webhook.token_filter.toLowerCase() !== signal.token.toLowerCase()) {
        return false;
      }
      
      return true;
    });

    // Fire webhooks (fire-and-forget, no await)
    matchingWebhooks.forEach(async (webhook) => {
      try {
        const response = await fetch(webhook.url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'User-Agent': 'BankrSignals-Webhook/1.0'
          },
          body: JSON.stringify({
            type: 'new_signal',
            signal,
            timestamp: new Date().toISOString()
          }),
          signal: AbortSignal.timeout(10000) // 10 second timeout
        });

        if (response.ok) {
          // Reset failure count on success
          await supabase
            .from("webhooks")
            .update({ 
              last_triggered: new Date().toISOString(),
              failures: 0 
            })
            .eq("id", webhook.id);
        } else {
          throw new Error(`HTTP ${response.status}`);
        }
      } catch (error: any) {
        // Increment failure count, deactivate after 10 failures
        const newFailures = (webhook.failures || 0) + 1;
        const updates: any = { failures: newFailures };
        
        if (newFailures >= 10) {
          updates.active = false;
        }
        
        await supabase
          .from("webhooks")
          .update(updates)
          .eq("id", webhook.id);
      }
    });
  } catch (error: any) {
    // Silently fail - don't interfere with signal creation
    console.error("Webhook firing error:", error);
  }
}

// GET /api/signals - List signals
export async function GET(req: NextRequest) {
  try {
    // Rate limiting for API reads
    const clientIP = getClientIP(req);
    const readLimit = checkRateLimit(`read:${clientIP}`, RATE_LIMITS.API_READ);
    
    if (!readLimit.allowed) {
      return rateLimitResponse(readLimit, "Too many API requests");
    }

    const { searchParams } = new URL(req.url);
    const provider = searchParams.get("provider");
    const category = searchParams.get("category");
    const status = searchParams.get("status");
    const token = searchParams.get("token");
    const riskLevel = searchParams.get("riskLevel");
    const page = Math.max(1, parseInt(searchParams.get("page") || "1"));
    const limit = Math.min(parseInt(searchParams.get("limit") || "50"), 200);
    const sortBy = searchParams.get("sortBy") || "timestamp";
    const order = searchParams.get("order") === "asc" ? "asc" : "desc";

    // Build query with enhanced filters
    let query = supabase
      .from("signals")
      .select("*", { count: "exact" });

    if (provider) {
      if (!ValidationPatterns.ETH_ADDRESS.test(provider)) {
        return createErrorResponse(
          APIErrorCode.VALIDATION_ERROR,
          "Invalid provider address format",
          400
        );
      }
      query = query.ilike("provider", provider);
    }

    if (category && VALID_CATEGORIES.includes(category as SignalCategory)) {
      query = query.eq("category", category);
    }

    if (status && Object.values(SignalStatus).includes(status as SignalStatus)) {
      query = query.eq("status", status);
    }

    if (token) {
      query = query.ilike("token", token);
    }

    if (riskLevel && VALID_RISK_LEVELS.includes(riskLevel as RiskLevel)) {
      query = query.eq("risk_level", riskLevel);
    }

    // Pagination
    const offset = (page - 1) * limit;
    query = query
      .range(offset, offset + limit - 1)
      .order(sortBy === "timestamp" ? "timestamp" : sortBy, { ascending: order === "asc" });

    const { data: signals, error, count } = await query;

    if (error) {
      console.error("Signals query error:", error);
      return createErrorResponse(
        APIErrorCode.INTERNAL_ERROR,
        "Database query failed",
        500
      );
    }

    // Format response with enhanced fields
    const formatted = (signals || []).map(dbToApiSignal);

    return createSuccessResponse(
      {
        signals: formatted,
        pagination: {
          page,
          limit,
          total: count || 0,
          hasMore: (count || 0) > offset + limit,
        },
      },
      200,
      {
        timestamp: new Date().toISOString(),
        pagination: {
          page,
          limit,
          total: count || 0,
          hasMore: (count || 0) > offset + limit,
        },
      }
    );
  } catch (error: any) {
    console.error("Signals GET error:", error);
    return createErrorResponse(
      APIErrorCode.INTERNAL_ERROR,
      "Internal server error",
      500
    );
  }
}

// POST /api/signals - Submit a new signal
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const {
      provider, action, token, chain, entryPrice,
      leverage, confidence, reasoning, txHash,
      stopLossPct, takeProfitPct, collateralUsd,
      message, signature,
    } = body;

    // Validate required fields
    if (!provider || !action || !token || !entryPrice || !txHash) {
      return NextResponse.json(
        { error: "Required fields: provider, action, token, entryPrice, txHash, collateralUsd" },
        { status: 400 }
      );
    }

    // Require collateralUsd (position size) - essential for PnL tracking
    if (collateralUsd === undefined || collateralUsd === null || collateralUsd === "") {
      return NextResponse.json(
        { error: "collateralUsd (position size in USD) is required. PnL cannot be calculated without it. Example: collateralUsd: 100" },
        { status: 400 }
      );
    }

    const parsedCollateral = parseFloat(collateralUsd);
    if (isNaN(parsedCollateral) || parsedCollateral <= 0) {
      return NextResponse.json(
        { error: "collateralUsd must be a positive number representing your position size in USD" },
        { status: 400 }
      );
    }

    // Validate txHash format
    if (!/^0x[a-fA-F0-9]{64}$/.test(txHash)) {
      return NextResponse.json(
        { error: "txHash must be a valid transaction hash (0x + 64 hex chars)" },
        { status: 400 }
      );
    }

    const addressValidation = CustomValidators.ethAddress(provider);
    if (addressValidation) {
      return createErrorResponse(APIErrorCode.VALIDATION_ERROR, addressValidation, 400);
    }

    if (!VALID_ACTIONS.includes(action.toUpperCase())) {
      return NextResponse.json({ error: `action must be one of: ${VALID_ACTIONS.join(", ")}` }, { status: 400 });
    }

    // Basic token validation - alphanumeric with some symbols
    if (!/^[A-Za-z0-9\-_\.]+$/.test(token) || token.length > 20) {
      return createErrorResponse(APIErrorCode.VALIDATION_ERROR, "Invalid token format", 400);
    }

    const parsedPrice = parseFloat(entryPrice);
    if (isNaN(parsedPrice) || parsedPrice <= 0) {
      return NextResponse.json({ error: "entryPrice must be a positive number" }, { status: 400 });
    }

    // Require signature
    if (!message || !signature) {
      return NextResponse.json(
        { error: "message and signature required. Format: bankr-signals:signal:{provider}:{action}:{token}:{timestamp}" },
        { status: 401 }
      );
    }

    // Validate message format
    const msgMatch = message.match(/^bankr-signals:signal:(0x[a-fA-F0-9]{40}):(\w+):(\w+):(\d+)$/);
    if (!msgMatch) {
      return NextResponse.json({ error: "Invalid message format" }, { status: 400 });
    }

    if (msgMatch[1].toLowerCase() !== provider.toLowerCase()) {
      return NextResponse.json({ error: "Provider in message does not match" }, { status: 400 });
    }

    // Check timestamp freshness
    const msgTimestamp = parseInt(msgMatch[4]);
    const now = Math.floor(Date.now() / 1000);
    if (Math.abs(now - msgTimestamp) > 300) {
      return NextResponse.json({ error: "Message timestamp expired" }, { status: 400 });
    }

    // Verify signature
    const valid = await verifySignature(provider, message, signature);
    if (!valid) {
      return NextResponse.json({ error: "Invalid signature" }, { status: 401 });
    }

    // Check provider is registered
    const providerRecord = await dbGetProvider(provider);
    if (!providerRecord) {
      return NextResponse.json({ error: "Provider not registered. POST /api/providers/register first." }, { status: 403 });
    }

    // Verify TX hash exists onchain (Base)
    try {
      const rpcUrl = process.env.BASE_RPC_URL || "https://mainnet.base.org";
      const txRes = await fetch(rpcUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0", id: 1, method: "eth_getTransactionReceipt",
          params: [txHash],
        }),
        signal: AbortSignal.timeout(10000),
      });
      const txData = await txRes.json();
      if (!txData.result) {
        return NextResponse.json(
          { error: "TX hash not found onchain. Submit a real transaction hash from Base." },
          { status: 400 }
        );
      }
      // Check if the provider's address is involved in the TX
      // (as sender, or in logs). Don't require exact from-match
      // because bundled/relayed TXs have the bundler as tx.from.
      const txFrom = txData.result.from?.toLowerCase();
      const providerLower = provider.toLowerCase();
      const logs = txData.result.logs || [];
      const involvedInLogs = logs.some((log: any) =>
        log.topics?.some((t: string) => t.toLowerCase().includes(providerLower.slice(2))) ||
        log.data?.toLowerCase().includes(providerLower.slice(2))
      );
      if (txFrom !== providerLower && !involvedInLogs) {
        return NextResponse.json(
          { error: `Provider address not found in TX. The transaction must involve your wallet (as sender or in event logs).` },
          { status: 400 }
        );
      }
    } catch (err: any) {
      // If RPC fails, log but don't block (availability > strictness)
      console.error("TX verification warning:", err.message);
    }

    // BUY/SELL are instant (spot trades) - auto-close
    // LONG/SHORT are leveraged positions - stay open until manually closed
    const actionUpper = action.toUpperCase();
    const isSpot = actionUpper === "BUY" || actionUpper === "SELL";

    // Generate signal ID
    const id = `sig_${Buffer.from(`${provider}:${Date.now()}:${Math.random()}`).toString("base64url").slice(0, 12)}`;

    const signal = await dbAddSignal({
      id, provider, action: actionUpper, token, chain: chain || "base",
      entryPrice: parsedPrice, leverage, confidence, reasoning, txHash,
      stopLossPct, takeProfitPct, collateralUsd,
      status: isSpot ? "closed" : "open",
    });

    // Fire webhooks (async, don't block response)
    fireWebhooks(signal);

    return NextResponse.json({ success: true, signal }, { status: 201 });
  } catch (error: any) {
    console.error("Signal POST error:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
